// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_data.proto

#ifndef PROTOBUF_common_5fdata_2eproto__INCLUDED
#define PROTOBUF_common_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Cell {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_5fdata_2eproto();
void protobuf_AssignDesc_common_5fdata_2eproto();
void protobuf_ShutdownFile_common_5fdata_2eproto();

class Geo;
class MessageMeta;
class UGC;
class UGCIdList;

enum Gender {
  GR_MALE = 0,
  GR_FEMALE = 1,
  GR_UNKNOW = 2
};
bool Gender_IsValid(int value);
const Gender Gender_MIN = GR_MALE;
const Gender Gender_MAX = GR_UNKNOW;
const int Gender_ARRAYSIZE = Gender_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gender_descriptor();
inline const ::std::string& Gender_Name(Gender value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gender_descriptor(), value);
}
inline bool Gender_Parse(
    const ::std::string& name, Gender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gender>(
    Gender_descriptor(), name, value);
}
enum RegSource {
  RS_NATIVE = 0,
  RS_WEIBO = 1,
  RS_WEIXIN = 2,
  RS_QQ = 3
};
bool RegSource_IsValid(int value);
const RegSource RegSource_MIN = RS_NATIVE;
const RegSource RegSource_MAX = RS_QQ;
const int RegSource_ARRAYSIZE = RegSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegSource_descriptor();
inline const ::std::string& RegSource_Name(RegSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegSource_descriptor(), value);
}
inline bool RegSource_Parse(
    const ::std::string& name, RegSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegSource>(
    RegSource_descriptor(), name, value);
}
enum DeviceType {
  DT_IOS = 0,
  DT_ANDROID = 1,
  DT_WP = 2
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = DT_IOS;
const DeviceType DeviceType_MAX = DT_WP;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum UserProfileType {
  US_PROFILE = 0,
  US_UGC_ACHIEVE = 1,
  US_PK_ACHIEVE = 2
};
bool UserProfileType_IsValid(int value);
const UserProfileType UserProfileType_MIN = US_PROFILE;
const UserProfileType UserProfileType_MAX = US_PK_ACHIEVE;
const int UserProfileType_ARRAYSIZE = UserProfileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserProfileType_descriptor();
inline const ::std::string& UserProfileType_Name(UserProfileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserProfileType_descriptor(), value);
}
inline bool UserProfileType_Parse(
    const ::std::string& name, UserProfileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserProfileType>(
    UserProfileType_descriptor(), name, value);
}
enum UserStat {
  US_REG_USER = 0,
  US_UNREG_USER = 1,
  US_UNKNOWN = 2
};
bool UserStat_IsValid(int value);
const UserStat UserStat_MIN = US_REG_USER;
const UserStat UserStat_MAX = US_UNKNOWN;
const int UserStat_ARRAYSIZE = UserStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserStat_descriptor();
inline const ::std::string& UserStat_Name(UserStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserStat_descriptor(), value);
}
inline bool UserStat_Parse(
    const ::std::string& name, UserStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserStat>(
    UserStat_descriptor(), name, value);
}
enum NetworkType {
  NT_2G = 0,
  NT_3G = 1,
  NT_4G = 2,
  NT_WIFI = 3
};
bool NetworkType_IsValid(int value);
const NetworkType NetworkType_MIN = NT_2G;
const NetworkType NetworkType_MAX = NT_WIFI;
const int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkType_descriptor();
inline const ::std::string& NetworkType_Name(NetworkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkType_descriptor(), value);
}
inline bool NetworkType_Parse(
    const ::std::string& name, NetworkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkType>(
    NetworkType_descriptor(), name, value);
}
enum UGCListType {
  UGC_GEN = 0,
  UGC_POST = 1,
  UGC_PASS = 2,
  UGC_COLLECT = 3
};
bool UGCListType_IsValid(int value);
const UGCListType UGCListType_MIN = UGC_GEN;
const UGCListType UGCListType_MAX = UGC_COLLECT;
const int UGCListType_ARRAYSIZE = UGCListType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UGCListType_descriptor();
inline const ::std::string& UGCListType_Name(UGCListType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UGCListType_descriptor(), value);
}
inline bool UGCListType_Parse(
    const ::std::string& name, UGCListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UGCListType>(
    UGCListType_descriptor(), name, value);
}
enum RetCode {
  RC_SUCCESS = 0,
  RC_PHONE_INVALID = 1,
  RC_INNER_ERROR = 2,
  RC_FAILED = 3,
  RC_SESSION_INVALID = 4
};
bool RetCode_IsValid(int value);
const RetCode RetCode_MIN = RC_SUCCESS;
const RetCode RetCode_MAX = RC_SESSION_INVALID;
const int RetCode_ARRAYSIZE = RetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RetCode_descriptor();
inline const ::std::string& RetCode_Name(RetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RetCode_descriptor(), value);
}
inline bool RetCode_Parse(
    const ::std::string& name, RetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RetCode>(
    RetCode_descriptor(), name, value);
}
enum TargetType {
  T_MALE = 0,
  T_FEMALE = 1,
  T_ALL = 2
};
bool TargetType_IsValid(int value);
const TargetType TargetType_MIN = T_MALE;
const TargetType TargetType_MAX = T_ALL;
const int TargetType_ARRAYSIZE = TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetType_descriptor();
inline const ::std::string& TargetType_Name(TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetType_descriptor(), value);
}
inline bool TargetType_Parse(
    const ::std::string& name, TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetType>(
    TargetType_descriptor(), name, value);
}
enum CardType {
  SPADE = 1,
  HEART = 2,
  DIAMOND = 3,
  CLUB = 4
};
bool CardType_IsValid(int value);
const CardType CardType_MIN = SPADE;
const CardType CardType_MAX = CLUB;
const int CardType_ARRAYSIZE = CardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CardType_descriptor();
inline const ::std::string& CardType_Name(CardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CardType_descriptor(), value);
}
inline bool CardType_Parse(
    const ::std::string& name, CardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CardType>(
    CardType_descriptor(), name, value);
}
enum ConfirmType {
  OK = 1,
  CANCEL = 2
};
bool ConfirmType_IsValid(int value);
const ConfirmType ConfirmType_MIN = OK;
const ConfirmType ConfirmType_MAX = CANCEL;
const int ConfirmType_ARRAYSIZE = ConfirmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConfirmType_descriptor();
inline const ::std::string& ConfirmType_Name(ConfirmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConfirmType_descriptor(), value);
}
inline bool ConfirmType_Parse(
    const ::std::string& name, ConfirmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConfirmType>(
    ConfirmType_descriptor(), name, value);
}
enum BloodType {
  BLOOD_A = 1,
  BLOOD_B = 2,
  BLOOD_AB = 3,
  BLOOD_O = 4
};
bool BloodType_IsValid(int value);
const BloodType BloodType_MIN = BLOOD_A;
const BloodType BloodType_MAX = BLOOD_O;
const int BloodType_ARRAYSIZE = BloodType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BloodType_descriptor();
inline const ::std::string& BloodType_Name(BloodType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BloodType_descriptor(), value);
}
inline bool BloodType_Parse(
    const ::std::string& name, BloodType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BloodType>(
    BloodType_descriptor(), name, value);
}
enum ConstellationType {
  ARIES = 1,
  TAURUS = 2,
  GEIMINI = 3,
  CANCER = 4,
  LEO = 5,
  VIRGO = 6,
  LIBRA = 7,
  SCORPIO = 8,
  SAGITTARIUS = 9,
  CAPRICORN = 10,
  AQUARIUS = 11,
  PISCES = 12
};
bool ConstellationType_IsValid(int value);
const ConstellationType ConstellationType_MIN = ARIES;
const ConstellationType ConstellationType_MAX = PISCES;
const int ConstellationType_ARRAYSIZE = ConstellationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConstellationType_descriptor();
inline const ::std::string& ConstellationType_Name(ConstellationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConstellationType_descriptor(), value);
}
inline bool ConstellationType_Parse(
    const ::std::string& name, ConstellationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConstellationType>(
    ConstellationType_descriptor(), name, value);
}
enum ZodiacType {
  MOUTH = 1,
  COW = 2,
  TIGGER = 3,
  RABBIT = 4,
  dragon = 5,
  SNAKE = 6,
  HORSE = 7,
  SHEEP = 8,
  MONKEY = 9,
  CHICKEN = 10,
  DOG = 11,
  PIG = 12
};
bool ZodiacType_IsValid(int value);
const ZodiacType ZodiacType_MIN = MOUTH;
const ZodiacType ZodiacType_MAX = PIG;
const int ZodiacType_ARRAYSIZE = ZodiacType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZodiacType_descriptor();
inline const ::std::string& ZodiacType_Name(ZodiacType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZodiacType_descriptor(), value);
}
inline bool ZodiacType_Parse(
    const ::std::string& name, ZodiacType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZodiacType>(
    ZodiacType_descriptor(), name, value);
}
enum PostType {
  PT_POST = 0,
  PT_PASS = 1
};
bool PostType_IsValid(int value);
const PostType PostType_MIN = PT_POST;
const PostType PostType_MAX = PT_PASS;
const int PostType_ARRAYSIZE = PostType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PostType_descriptor();
inline const ::std::string& PostType_Name(PostType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PostType_descriptor(), value);
}
inline bool PostType_Parse(
    const ::std::string& name, PostType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PostType>(
    PostType_descriptor(), name, value);
}
enum PullType {
  PT_PULL = 0,
  PT_PLAY = 1
};
bool PullType_IsValid(int value);
const PullType PullType_MIN = PT_PULL;
const PullType PullType_MAX = PT_PLAY;
const int PullType_ARRAYSIZE = PullType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PullType_descriptor();
inline const ::std::string& PullType_Name(PullType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PullType_descriptor(), value);
}
inline bool PullType_Parse(
    const ::std::string& name, PullType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PullType>(
    PullType_descriptor(), name, value);
}
enum CommentType {
  USER_POST_TYPE = 0,
  USER_RECV_TYPE = 1,
  MSG_TYPE = 2
};
bool CommentType_IsValid(int value);
const CommentType CommentType_MIN = USER_POST_TYPE;
const CommentType CommentType_MAX = MSG_TYPE;
const int CommentType_ARRAYSIZE = CommentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommentType_descriptor();
inline const ::std::string& CommentType_Name(CommentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommentType_descriptor(), value);
}
inline bool CommentType_Parse(
    const ::std::string& name, CommentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommentType>(
    CommentType_descriptor(), name, value);
}
// ===================================================================

class Geo : public ::google::protobuf::Message {
 public:
  Geo();
  virtual ~Geo();

  Geo(const Geo& from);

  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geo& default_instance();

  void Swap(Geo* other);

  // implements Message ----------------------------------------------

  Geo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Geo& from);
  void MergeFrom(const Geo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline float latitude() const;
  inline void set_latitude(float value);

  // required float longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline float longitude() const;
  inline void set_longitude(float value);

  // @@protoc_insertion_point(class_scope:Cell.Geo)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float latitude_;
  float longitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fdata_2eproto();
  friend void protobuf_AssignDesc_common_5fdata_2eproto();
  friend void protobuf_ShutdownFile_common_5fdata_2eproto();

  void InitAsDefaultInstance();
  static Geo* default_instance_;
};
// -------------------------------------------------------------------

class MessageMeta : public ::google::protobuf::Message {
 public:
  MessageMeta();
  virtual ~MessageMeta();

  MessageMeta(const MessageMeta& from);

  inline MessageMeta& operator=(const MessageMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageMeta& default_instance();

  void Swap(MessageMeta* other);

  // implements Message ----------------------------------------------

  MessageMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageMeta& from);
  void MergeFrom(const MessageMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // repeated string image = 2;
  inline int image_size() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::std::string& image(int index) const;
  inline ::std::string* mutable_image(int index);
  inline void set_image(int index, const ::std::string& value);
  inline void set_image(int index, const char* value);
  inline void set_image(int index, const char* value, size_t size);
  inline ::std::string* add_image();
  inline void add_image(const ::std::string& value);
  inline void add_image(const char* value);
  inline void add_image(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& image() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_image();

  // repeated string voice = 3;
  inline int voice_size() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 3;
  inline const ::std::string& voice(int index) const;
  inline ::std::string* mutable_voice(int index);
  inline void set_voice(int index, const ::std::string& value);
  inline void set_voice(int index, const char* value);
  inline void set_voice(int index, const char* value, size_t size);
  inline ::std::string* add_voice();
  inline void add_voice(const ::std::string& value);
  inline void add_voice(const char* value);
  inline void add_voice(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& voice() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_voice();

  // repeated string video = 4;
  inline int video_size() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 4;
  inline const ::std::string& video(int index) const;
  inline ::std::string* mutable_video(int index);
  inline void set_video(int index, const ::std::string& value);
  inline void set_video(int index, const char* value);
  inline void set_video(int index, const char* value, size_t size);
  inline ::std::string* add_video();
  inline void add_video(const ::std::string& value);
  inline void add_video(const char* value);
  inline void add_video(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& video() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_video();

  // repeated string img_size = 5;
  inline int img_size_size() const;
  inline void clear_img_size();
  static const int kImgSizeFieldNumber = 5;
  inline const ::std::string& img_size(int index) const;
  inline ::std::string* mutable_img_size(int index);
  inline void set_img_size(int index, const ::std::string& value);
  inline void set_img_size(int index, const char* value);
  inline void set_img_size(int index, const char* value, size_t size);
  inline ::std::string* add_img_size();
  inline void add_img_size(const ::std::string& value);
  inline void add_img_size(const char* value);
  inline void add_img_size(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& img_size() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_img_size();

  // @@protoc_insertion_point(class_scope:Cell.MessageMeta)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::google::protobuf::RepeatedPtrField< ::std::string> image_;
  ::google::protobuf::RepeatedPtrField< ::std::string> voice_;
  ::google::protobuf::RepeatedPtrField< ::std::string> video_;
  ::google::protobuf::RepeatedPtrField< ::std::string> img_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fdata_2eproto();
  friend void protobuf_AssignDesc_common_5fdata_2eproto();
  friend void protobuf_ShutdownFile_common_5fdata_2eproto();

  void InitAsDefaultInstance();
  static MessageMeta* default_instance_;
};
// -------------------------------------------------------------------

class UGC : public ::google::protobuf::Message {
 public:
  UGC();
  virtual ~UGC();

  UGC(const UGC& from);

  inline UGC& operator=(const UGC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UGC& default_instance();

  void Swap(UGC* other);

  // implements Message ----------------------------------------------

  UGC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UGC& from);
  void MergeFrom(const UGC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cell.MessageMeta message_meta = 1;
  inline bool has_message_meta() const;
  inline void clear_message_meta();
  static const int kMessageMetaFieldNumber = 1;
  inline const ::Cell::MessageMeta& message_meta() const;
  inline ::Cell::MessageMeta* mutable_message_meta();
  inline ::Cell::MessageMeta* release_message_meta();
  inline void set_allocated_message_meta(::Cell::MessageMeta* message_meta);

  // optional .Cell.Geo geo = 2;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 2;
  inline const ::Cell::Geo& geo() const;
  inline ::Cell::Geo* mutable_geo();
  inline ::Cell::Geo* release_geo();
  inline void set_allocated_geo(::Cell::Geo* geo);

  // optional .Cell.TargetType target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline ::Cell::TargetType target() const;
  inline void set_target(::Cell::TargetType value);

  // optional .Cell.CardType card_type = 4;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 4;
  inline ::Cell::CardType card_type() const;
  inline void set_card_type(::Cell::CardType value);

  // @@protoc_insertion_point(class_scope:Cell.UGC)
 private:
  inline void set_has_message_meta();
  inline void clear_has_message_meta();
  inline void set_has_geo();
  inline void clear_has_geo();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_card_type();
  inline void clear_has_card_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Cell::MessageMeta* message_meta_;
  ::Cell::Geo* geo_;
  int target_;
  int card_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fdata_2eproto();
  friend void protobuf_AssignDesc_common_5fdata_2eproto();
  friend void protobuf_ShutdownFile_common_5fdata_2eproto();

  void InitAsDefaultInstance();
  static UGC* default_instance_;
};
// -------------------------------------------------------------------

class UGCIdList : public ::google::protobuf::Message {
 public:
  UGCIdList();
  virtual ~UGCIdList();

  UGCIdList(const UGCIdList& from);

  inline UGCIdList& operator=(const UGCIdList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UGCIdList& default_instance();

  void Swap(UGCIdList* other);

  // implements Message ----------------------------------------------

  UGCIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UGCIdList& from);
  void MergeFrom(const UGCIdList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ugc_id = 1;
  inline bool has_ugc_id() const;
  inline void clear_ugc_id();
  static const int kUgcIdFieldNumber = 1;
  inline ::google::protobuf::uint64 ugc_id() const;
  inline void set_ugc_id(::google::protobuf::uint64 value);

  // optional uint32 org_uid = 2;
  inline bool has_org_uid() const;
  inline void clear_org_uid();
  static const int kOrgUidFieldNumber = 2;
  inline ::google::protobuf::uint32 org_uid() const;
  inline void set_org_uid(::google::protobuf::uint32 value);

  // optional uint64 msid = 3;
  inline bool has_msid() const;
  inline void clear_msid();
  static const int kMsidFieldNumber = 3;
  inline ::google::protobuf::uint64 msid() const;
  inline void set_msid(::google::protobuf::uint64 value);

  // optional uint64 mstid = 4;
  inline bool has_mstid() const;
  inline void clear_mstid();
  static const int kMstidFieldNumber = 4;
  inline ::google::protobuf::uint64 mstid() const;
  inline void set_mstid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Cell.UGCIdList)
 private:
  inline void set_has_ugc_id();
  inline void clear_has_ugc_id();
  inline void set_has_org_uid();
  inline void clear_has_org_uid();
  inline void set_has_msid();
  inline void clear_has_msid();
  inline void set_has_mstid();
  inline void clear_has_mstid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ugc_id_;
  ::google::protobuf::uint64 msid_;
  ::google::protobuf::uint64 mstid_;
  ::google::protobuf::uint32 org_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fdata_2eproto();
  friend void protobuf_AssignDesc_common_5fdata_2eproto();
  friend void protobuf_ShutdownFile_common_5fdata_2eproto();

  void InitAsDefaultInstance();
  static UGCIdList* default_instance_;
};
// ===================================================================


// ===================================================================

// Geo

// required float latitude = 1;
inline bool Geo::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geo::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Geo::latitude() const {
  return latitude_;
}
inline void Geo::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// required float longitude = 2;
inline bool Geo::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geo::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Geo::longitude() const {
  return longitude_;
}
inline void Geo::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// -------------------------------------------------------------------

// MessageMeta

// optional string content = 1;
inline bool MessageMeta::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageMeta::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageMeta::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageMeta::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MessageMeta::content() const {
  return *content_;
}
inline void MessageMeta::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MessageMeta::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MessageMeta::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageMeta::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* MessageMeta::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageMeta::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string image = 2;
inline int MessageMeta::image_size() const {
  return image_.size();
}
inline void MessageMeta::clear_image() {
  image_.Clear();
}
inline const ::std::string& MessageMeta::image(int index) const {
  return image_.Get(index);
}
inline ::std::string* MessageMeta::mutable_image(int index) {
  return image_.Mutable(index);
}
inline void MessageMeta::set_image(int index, const ::std::string& value) {
  image_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_image(int index, const char* value) {
  image_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_image(int index, const char* value, size_t size) {
  image_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageMeta::add_image() {
  return image_.Add();
}
inline void MessageMeta::add_image(const ::std::string& value) {
  image_.Add()->assign(value);
}
inline void MessageMeta::add_image(const char* value) {
  image_.Add()->assign(value);
}
inline void MessageMeta::add_image(const char* value, size_t size) {
  image_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageMeta::image() const {
  return image_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageMeta::mutable_image() {
  return &image_;
}

// repeated string voice = 3;
inline int MessageMeta::voice_size() const {
  return voice_.size();
}
inline void MessageMeta::clear_voice() {
  voice_.Clear();
}
inline const ::std::string& MessageMeta::voice(int index) const {
  return voice_.Get(index);
}
inline ::std::string* MessageMeta::mutable_voice(int index) {
  return voice_.Mutable(index);
}
inline void MessageMeta::set_voice(int index, const ::std::string& value) {
  voice_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_voice(int index, const char* value) {
  voice_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_voice(int index, const char* value, size_t size) {
  voice_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageMeta::add_voice() {
  return voice_.Add();
}
inline void MessageMeta::add_voice(const ::std::string& value) {
  voice_.Add()->assign(value);
}
inline void MessageMeta::add_voice(const char* value) {
  voice_.Add()->assign(value);
}
inline void MessageMeta::add_voice(const char* value, size_t size) {
  voice_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageMeta::voice() const {
  return voice_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageMeta::mutable_voice() {
  return &voice_;
}

// repeated string video = 4;
inline int MessageMeta::video_size() const {
  return video_.size();
}
inline void MessageMeta::clear_video() {
  video_.Clear();
}
inline const ::std::string& MessageMeta::video(int index) const {
  return video_.Get(index);
}
inline ::std::string* MessageMeta::mutable_video(int index) {
  return video_.Mutable(index);
}
inline void MessageMeta::set_video(int index, const ::std::string& value) {
  video_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_video(int index, const char* value) {
  video_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_video(int index, const char* value, size_t size) {
  video_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageMeta::add_video() {
  return video_.Add();
}
inline void MessageMeta::add_video(const ::std::string& value) {
  video_.Add()->assign(value);
}
inline void MessageMeta::add_video(const char* value) {
  video_.Add()->assign(value);
}
inline void MessageMeta::add_video(const char* value, size_t size) {
  video_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageMeta::video() const {
  return video_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageMeta::mutable_video() {
  return &video_;
}

// repeated string img_size = 5;
inline int MessageMeta::img_size_size() const {
  return img_size_.size();
}
inline void MessageMeta::clear_img_size() {
  img_size_.Clear();
}
inline const ::std::string& MessageMeta::img_size(int index) const {
  return img_size_.Get(index);
}
inline ::std::string* MessageMeta::mutable_img_size(int index) {
  return img_size_.Mutable(index);
}
inline void MessageMeta::set_img_size(int index, const ::std::string& value) {
  img_size_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_img_size(int index, const char* value) {
  img_size_.Mutable(index)->assign(value);
}
inline void MessageMeta::set_img_size(int index, const char* value, size_t size) {
  img_size_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageMeta::add_img_size() {
  return img_size_.Add();
}
inline void MessageMeta::add_img_size(const ::std::string& value) {
  img_size_.Add()->assign(value);
}
inline void MessageMeta::add_img_size(const char* value) {
  img_size_.Add()->assign(value);
}
inline void MessageMeta::add_img_size(const char* value, size_t size) {
  img_size_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageMeta::img_size() const {
  return img_size_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageMeta::mutable_img_size() {
  return &img_size_;
}

// -------------------------------------------------------------------

// UGC

// optional .Cell.MessageMeta message_meta = 1;
inline bool UGC::has_message_meta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UGC::set_has_message_meta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UGC::clear_has_message_meta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UGC::clear_message_meta() {
  if (message_meta_ != NULL) message_meta_->::Cell::MessageMeta::Clear();
  clear_has_message_meta();
}
inline const ::Cell::MessageMeta& UGC::message_meta() const {
  return message_meta_ != NULL ? *message_meta_ : *default_instance_->message_meta_;
}
inline ::Cell::MessageMeta* UGC::mutable_message_meta() {
  set_has_message_meta();
  if (message_meta_ == NULL) message_meta_ = new ::Cell::MessageMeta;
  return message_meta_;
}
inline ::Cell::MessageMeta* UGC::release_message_meta() {
  clear_has_message_meta();
  ::Cell::MessageMeta* temp = message_meta_;
  message_meta_ = NULL;
  return temp;
}
inline void UGC::set_allocated_message_meta(::Cell::MessageMeta* message_meta) {
  delete message_meta_;
  message_meta_ = message_meta;
  if (message_meta) {
    set_has_message_meta();
  } else {
    clear_has_message_meta();
  }
}

// optional .Cell.Geo geo = 2;
inline bool UGC::has_geo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UGC::set_has_geo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UGC::clear_has_geo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UGC::clear_geo() {
  if (geo_ != NULL) geo_->::Cell::Geo::Clear();
  clear_has_geo();
}
inline const ::Cell::Geo& UGC::geo() const {
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::Cell::Geo* UGC::mutable_geo() {
  set_has_geo();
  if (geo_ == NULL) geo_ = new ::Cell::Geo;
  return geo_;
}
inline ::Cell::Geo* UGC::release_geo() {
  clear_has_geo();
  ::Cell::Geo* temp = geo_;
  geo_ = NULL;
  return temp;
}
inline void UGC::set_allocated_geo(::Cell::Geo* geo) {
  delete geo_;
  geo_ = geo;
  if (geo) {
    set_has_geo();
  } else {
    clear_has_geo();
  }
}

// optional .Cell.TargetType target = 3;
inline bool UGC::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UGC::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UGC::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UGC::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::Cell::TargetType UGC::target() const {
  return static_cast< ::Cell::TargetType >(target_);
}
inline void UGC::set_target(::Cell::TargetType value) {
  assert(::Cell::TargetType_IsValid(value));
  set_has_target();
  target_ = value;
}

// optional .Cell.CardType card_type = 4;
inline bool UGC::has_card_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UGC::set_has_card_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UGC::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UGC::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Cell::CardType UGC::card_type() const {
  return static_cast< ::Cell::CardType >(card_type_);
}
inline void UGC::set_card_type(::Cell::CardType value) {
  assert(::Cell::CardType_IsValid(value));
  set_has_card_type();
  card_type_ = value;
}

// -------------------------------------------------------------------

// UGCIdList

// optional uint64 ugc_id = 1;
inline bool UGCIdList::has_ugc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UGCIdList::set_has_ugc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UGCIdList::clear_has_ugc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UGCIdList::clear_ugc_id() {
  ugc_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ugc_id();
}
inline ::google::protobuf::uint64 UGCIdList::ugc_id() const {
  return ugc_id_;
}
inline void UGCIdList::set_ugc_id(::google::protobuf::uint64 value) {
  set_has_ugc_id();
  ugc_id_ = value;
}

// optional uint32 org_uid = 2;
inline bool UGCIdList::has_org_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UGCIdList::set_has_org_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UGCIdList::clear_has_org_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UGCIdList::clear_org_uid() {
  org_uid_ = 0u;
  clear_has_org_uid();
}
inline ::google::protobuf::uint32 UGCIdList::org_uid() const {
  return org_uid_;
}
inline void UGCIdList::set_org_uid(::google::protobuf::uint32 value) {
  set_has_org_uid();
  org_uid_ = value;
}

// optional uint64 msid = 3;
inline bool UGCIdList::has_msid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UGCIdList::set_has_msid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UGCIdList::clear_has_msid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UGCIdList::clear_msid() {
  msid_ = GOOGLE_ULONGLONG(0);
  clear_has_msid();
}
inline ::google::protobuf::uint64 UGCIdList::msid() const {
  return msid_;
}
inline void UGCIdList::set_msid(::google::protobuf::uint64 value) {
  set_has_msid();
  msid_ = value;
}

// optional uint64 mstid = 4;
inline bool UGCIdList::has_mstid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UGCIdList::set_has_mstid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UGCIdList::clear_has_mstid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UGCIdList::clear_mstid() {
  mstid_ = GOOGLE_ULONGLONG(0);
  clear_has_mstid();
}
inline ::google::protobuf::uint64 UGCIdList::mstid() const {
  return mstid_;
}
inline void UGCIdList::set_mstid(::google::protobuf::uint64 value) {
  set_has_mstid();
  mstid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cell

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::Gender>() {
  return ::Cell::Gender_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::RegSource>() {
  return ::Cell::RegSource_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::DeviceType>() {
  return ::Cell::DeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::UserProfileType>() {
  return ::Cell::UserProfileType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::UserStat>() {
  return ::Cell::UserStat_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::NetworkType>() {
  return ::Cell::NetworkType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::UGCListType>() {
  return ::Cell::UGCListType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::RetCode>() {
  return ::Cell::RetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::TargetType>() {
  return ::Cell::TargetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::CardType>() {
  return ::Cell::CardType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::ConfirmType>() {
  return ::Cell::ConfirmType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::BloodType>() {
  return ::Cell::BloodType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::ConstellationType>() {
  return ::Cell::ConstellationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::ZodiacType>() {
  return ::Cell::ZodiacType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::PostType>() {
  return ::Cell::PostType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::PullType>() {
  return ::Cell::PullType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cell::CommentType>() {
  return ::Cell::CommentType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_5fdata_2eproto__INCLUDED
